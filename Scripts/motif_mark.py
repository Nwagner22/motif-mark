#!/usr/bin/env python3
# coding: utf-8

"""
Nick Wagner
2/17/20

Program to parse fasta files and illustrate motifs
"""

import sys
import argparse
from motif_class import *
from drawer_class import *
from helpers import *

def get_args():
    parser = argparse.ArgumentParser(description="A program to parse fasta files and illustrate morifs")
    parser.add_argument("-f", "--fasta", help="use to specify input .fasta file name. Required to be in two-line fasta format", required=True, type = str)  
    parser.add_argument("-m", "--motif", help="use to specify file that contains all of the desired motifs", required=True, type = str)
    parser.add_argument("-o", "--output", help="use to specify output file name with a file extenison of .svg  DEFAULT = motif_output.svg", required=False, type = str, default='motif_output.svg')  
    return parser.parse_args()

args = get_args()
FASTA_FILE = args.fasta
MOTIF_FILE = args.motif
OUTPUT_FILE = args.output
LIST_OF_GIVEN_MOTIFS = []   # List of the actual motifs read in from the file
LIST_OF_GIVEN_MOTIF_EXPRESSIONS = [] # List of the motif expressions generated by using the ambiguity codes in the dictionary below
LIST_OF_GIVEN_MOTIF_LENGTHS = [] # List of lenths of each of the motifs - corresponds to LIST_OF_GIVEN_MOTIFS
LIST_OF_MOTIF_OBJECTS = []  # List that holds the motif objects as they are created by parsing through the fasta file
NUMBER_OF_MOTIFS = 0 # Counter that keeps track of the number of motifs given

# dictionary that is used for generating the motif expressions used in regex
# key: the lowercase value of all of the ambiguity codes
# value: string that corresponds to the upper or lower values the ambiguity code could be
nucleac_acid_dict = {'y':'[tcuTCU]', 'u':'[utUT]','s':'[cgCG]', 'm':'[acAC]',
                     'k':'[gtuGTU]', 'r':'[agAG]', 'w':'[atuATU]', 'a':'[aA]',
                     'c':'[cC]', 'g':'[gG]', 't':'[utUT]', 'b':'[cgtuCGTU]',
                     'd':'[agtuAGTU]', 'h':'[actuACTU]', 'v':'[acgACG]',
                     'n':'acgtuACGTU'}

# Loop that goes through the file contining the motifs and keeps track of the info listed above
with open(MOTIF_FILE, 'r') as motifFile:
    for line in motifFile:
        line = line.strip()
        LIST_OF_GIVEN_MOTIFS.append(line)

        current_length = len(line)
        line = line.lower()

        current_motif = ""
        # Loops through each of the letters in the motif and replaces it with the value associated in the
        # nucleac_acid_dict listed above
        # builds onto the blank current_motif string and stores in LIST_OF_GIVEN_MOTIF_EXPRESSIONS
        for letter in line:
            current_motif += nucleac_acid_dict[letter]

        LIST_OF_GIVEN_MOTIF_EXPRESSIONS.append(current_motif)
        LIST_OF_GIVEN_MOTIF_LENGTHS.append(current_length)
        NUMBER_OF_MOTIFS += 1


# Loop through the fasta file and create a motif object for each record
# This loop utilizes functions from the helpers.py file to get all of the
# information about motifs and exons
with open(FASTA_FILE, 'r') as fastaFile:
    count = 0
    for line in fastaFile:
        if(line[0] == '>'):  # header line, grab whole record
            # Keeps track of both header and sequence (REQUIRES 2-LINE FASTA)
            header = line.strip()
            sequence = fastaFile.readline().strip()
            # Initializes the current_motif_object with the header and sequence of the current record
            current_motif_object = motif(header,sequence)
            
            # Functions from helpers.py
            motif_output = find_motifs(sequence, LIST_OF_GIVEN_MOTIF_EXPRESSIONS,LIST_OF_GIVEN_MOTIF_LENGTHS)
            exon_coordinates = find_exon(sequence)

            # Utilizes motif class functions to add information about the motifs and exons
            current_motif_object.add_motif_sequences(motif_output[0])
            current_motif_object.add_motif_coordinates(motif_output[1])
            current_motif_object.add_motif_counts(motif_output[2])
            current_motif_object.add_exon(exon_coordinates)

            # Append the current motif object once all of the information in the record
            # is kept track of
            LIST_OF_MOTIF_OBJECTS.append(current_motif_object)

            count += 1

# Initialize drawer object with all of the motif objects as well as the number of
# motifs and the LIST_OF_GIVEN_MOTIFS
# draw() function is then called with the desired file output name
drawer_object = drawer(LIST_OF_MOTIF_OBJECTS, NUMBER_OF_MOTIFS, LIST_OF_GIVEN_MOTIFS)
drawer_object.draw(OUTPUT_FILE)

# print(LIST_OF_MOTIF_OBJECTS[0].exon_coordinates)
# print(LIST_OF_MOTIF_OBJECTS[1].exon_coordinates)
# print(LIST_OF_MOTIF_OBJECTS[2].exon_coordinates)
# print(LIST_OF_MOTIF_OBJECTS[3].exon_coordinates)

# print("")

# print(LIST_OF_MOTIF_OBJECTS[0].motif_counts, sum(LIST_OF_MOTIF_OBJECTS[0].motif_counts))
# print(LIST_OF_MOTIF_OBJECTS[1].motif_counts, sum(LIST_OF_MOTIF_OBJECTS[1].motif_counts))
# print(LIST_OF_MOTIF_OBJECTS[2].motif_counts, sum(LIST_OF_MOTIF_OBJECTS[2].motif_counts))
# print(LIST_OF_MOTIF_OBJECTS[3].motif_counts, sum(LIST_OF_MOTIF_OBJECTS[3].motif_counts))











# test_class = motif(motif_seq = 'AAAAAA', header="test")

# test_class.test()
